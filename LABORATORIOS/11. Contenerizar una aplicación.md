# Contenerizar una aplicación


## Obtener la app
Clonar el repositorio de ejemplo:

```bash
git clone https://github.com/docker/getting-started-app.git
````

Contenido del repositorio:

```
getting-started-app/
├── .dockerignore
├── package.json
├── README.md
├── spec/
├── src/
└── yarn.lock
```

---

## Construir la imagen de la app

Crear un `Dockerfile` en el directorio `getting-started-app/`:

```dockerfile
# syntax=docker/dockerfile:1
FROM node:lts-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
EXPOSE 3000
```

Construir la imagen:

```bash
cd /ruta/a/getting-started-app
docker build -t getting-started .
```

---

## Iniciar un contenedor de la app

```bash
docker run -d -p 127.0.0.1:3000:3000 getting-started
```

* `-d`: ejecuta en segundo plano.
* `-p HOST:CONTAINER`: mapea el puerto 3000 del contenedor al 3000 de tu host.

Ver contenedores en ejecución:

```bash
docker ps
```

---

## Actualizar la aplicación

Modificar el archivo `src/static/js/app.js`:

```diff
- <p className="text-center">No items yet! Add one above!</p>
+ <p className="text-center">You have no todo items yet! Add one above!</p>
```

Reconstruir la imagen:

```bash
docker build -t getting-started .
```

Detener y eliminar el contenedor antiguo:

```bash
docker stop <container-id>
docker rm <container-id>
```

Iniciar el contenedor actualizado:

```bash
docker run -dp 127.0.0.1:3000:3000 getting-started
```

---

## Compartir la aplicación

1. Crear un repositorio en Docker Hub.
2. Etiquetar la imagen correctamente:

```bash
docker tag getting-started TU-USUARIO/getting-started
```

3. Iniciar sesión y subir la imagen:

```bash
docker login TU-USUARIO
docker push TU-USUARIO/getting-started
```

4. Ejecutar la imagen en otra máquina:

```bash
docker run -dp 0.0.0.0:3000:3000 TU-USUARIO/getting-started
```

---

## Persistir los datos

Crear un volumen para la base de datos:

```bash
docker volume create todo-db
```

Iniciar contenedor con volumen montado:

```bash
docker run -dp 127.0.0.1:3000:3000 \
  --mount type=volume,src=todo-db,target=/etc/todos \
  getting-started
```

Verificar persistencia agregando elementos, eliminando el contenedor y volviendo a iniciar.

---

## Usar bind mounts para desarrollo

```bash
docker run -dp 127.0.0.1:3000:3000 \
  -w /app --mount type=bind,src="$(pwd)",target=/app \
  node:lts-alpine \
  sh -c "yarn install && yarn run dev"
```

* Permite que los cambios en el host se reflejen en el contenedor.
* Usar `nodemon` para reiniciar automáticamente la app al guardar cambios.

---

## Apps multi-contenedor con MySQL

1. Crear una red:

```bash
docker network create todo-app
```

2. Iniciar MySQL:

```bash
docker run -d \
  --network todo-app --network-alias mysql \
  -v todo-mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=secret \
  -e MYSQL_DATABASE=todos \
  mysql:8.0
```

3. Conectar la app a MySQL:

```bash
docker run -dp 127.0.0.1:3000:3000 \
  -w /app -v "$(pwd):/app" \
  --network todo-app \
  -e MYSQL_HOST=mysql \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:lts-alpine \
  sh -c "yarn install && yarn run dev"
```

---

## Docker Compose

Archivo `compose.yaml` completo:

```yaml
services:
  app:
    image: node:lts-alpine
    command: sh -c "yarn install && yarn run dev"
    ports:
      - 127.0.0.1:3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:8.0
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
```

Iniciar stack:

```bash
docker compose up -d
```

Detener y eliminar todo:

```bash
docker compose down --volumes
```

---

## Buenas prácticas de construcción de imágenes

* **Capas de imagen**: cada instrucción del Dockerfile crea una capa.
* **Caché de capas**: reorganizar el Dockerfile ayuda a reutilizar capas y acelerar builds.
* **Build multi-stage**: separar dependencias de compilación de las de runtime.

Ejemplo Node.js optimizado:

```dockerfile
FROM node:lts-alpine
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --production
COPY . .
CMD ["node", "src/index.js"]
```

Ejemplo React con multi-stage:

```dockerfile
FROM node:lts AS build
WORKDIR /app
COPY package* yarn.lock ./
RUN yarn install
COPY public ./public
COPY src ./src
RUN yarn run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
```

```
```
