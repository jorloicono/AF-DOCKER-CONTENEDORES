Esta guía te enseña, **paso a paso**, cómo crear una aplicación Node.js simple, contenerizarla con Docker y automatizar su construcción, testeo y publicación con **GitHub Actions** (CI/CD completo).

---

## Estructura del Proyecto

```

my-app/
├── .github/
│   └── workflows/
│       ├── ci-build-test.yml
│       └── release-multiarch.yml
├── src/
│   ├── index.js
│   └── routes.js
├── tests/
│   └── api.test.js
├── .dockerignore
├── Dockerfile
├── package.json
└── README.md

````

---

## 1. Código de la Aplicación

### `package.json`
```json
{
  "name": "my-app",
  "version": "1.0.0",
  "description": "Ejemplo mínimo de API en Node.js para CI/CD con Docker y GitHub Actions",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest --runInBand --coverage",
    "build": "echo \"no build step for this simple app\""
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "jest": "^29.6.1",
    "supertest": "^6.3.3",
    "nodemon": "^3.0.1"
  }
}
````

---

### `src/index.js`

```js
const express = require('express');
const routes = require('./routes');

const app = express();
app.use(express.json());
app.use('/', routes);

app.get('/healthz', (req, res) => res.json({ ok: true, ts: Date.now() }));

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ error: 'internal_server_error' });
});

if (require.main === module) {
  const port = process.env.PORT || 3000;
  app.listen(port, () => console.log(`✅ Server running on port ${port}`));
}

module.exports = app;
```

---

### `src/routes.js`

```js
const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  res.json({
    message: 'Hola desde my-app!',
    version: process.env.APP_VERSION || 'dev'
  });
});

router.get('/time', (req, res) => {
  res.json({ now: new Date().toISOString() });
});

module.exports = router;
```

---

##  2. Pruebas Automatizadas

### `tests/api.test.js`

```js
const request = require('supertest');
const app = require('../src/index');

describe('API básica', () => {
  test('GET / devuelve mensaje y versión', async () => {
    const res = await request(app).get('/');
    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('message', 'Hola desde my-app!');
  });

  test('GET /time devuelve fecha ISO', async () => {
    const res = await request(app).get('/time');
    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('now');
  });

  test('GET /healthz ok', async () => {
    const res = await request(app).get('/healthz');
    expect(res.statusCode).toBe(200);
    expect(res.body.ok).toBe(true);
  });
});
```

---

##  3. Docker

### `.dockerignore`

```
node_modules
npm-debug.log
.git
.gitignore
tests
coverage
```

---

### `Dockerfile`

```dockerfile
# Etapa de build
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Etapa final
FROM node:18-alpine
WORKDIR /app
COPY --from=build /app /app
RUN npm ci --omit=dev
EXPOSE 3000
ENV NODE_ENV=production
CMD ["npm", "start"]
LABEL org.opencontainers.image.source="https://github.com/OWNER/REPO"
```

 **Explicación:**

* `multi-stage build`: primero se instalan dependencias y se ejecuta build, luego solo se copian los artefactos finales.
* `--omit=dev`: no lleva dependencias de desarrollo.
* `LABEL`: útil para trazabilidad dentro de GHCR.

---

## 4. GitHub Actions – CI/CD

### Workflow 1: CI (Build + Test)

Ruta: `.github/workflows/ci-build-test.yml`

```yaml
name: CI - Build and Test

on:
  pull_request:
  push:
    branches: [ "main" ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build Docker image (no push)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
```

**Qué hace:**

1. Ejecuta pruebas automáticamente en cada *push* o *pull request*.
2. Construye la imagen Docker localmente para validar que compile correctamente.

---

### Workflow 2: CD (Build + Push Multi-Arch)

Ruta: `.github/workflows/release-multiarch.yml`

```yaml
name: Release - Build & Push Multi-Arch Image

on:
  push:
    tags:
      - 'v*.*.*' # Ejecutar solo al publicar una versión

env:
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/my-app

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & Push Multi-Arch Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache,mode=max
```

---

## 5. Configurar Secrets

Ve a **Settings → Secrets → Actions** y agrega:

| Nombre                      | Descripción                                      |
| --------------------------- | ------------------------------------------------ |
| `DOCKERHUB_USERNAME`        | Tu usuario de Docker Hub                         |
| `DOCKERHUB_TOKEN`           | Token de acceso de Docker Hub                    |
| *(Opcional)* `GITHUB_TOKEN` | GitHub la crea automáticamente (sirve para GHCR) |

> Si solo usarás **GHCR**, no necesitas crear tokens adicionales.

---

## 6. Cómo usar

### Construir localmente

```bash
docker build -t my-app .
docker run -p 3000:3000 my-app
```

Abre [http://localhost:3000](http://localhost:3000) → deberías ver el JSON:

```json
{ "message": "Hola desde my-app!", "version": "dev" }
```

---

### Probar

```bash
npm install
npm test
```

---

### Publicar nueva versión

1. Aumenta la versión:

   ```bash
   git tag v1.0.0
   git push origin v1.0.0
   ```
2. El workflow **release-multiarch** construirá y subirá la imagen multi-arquitectura a GHCR:

   ```
   ghcr.io/<tu_usuario>/my-app:latest
   ghcr.io/<tu_usuario>/my-app:v1.0.0
   ```

---

## 7. Ejemplo de salida esperada

**Al ejecutar localmente:**

```bash
$ curl http://localhost:3000/
{"message":"Hola desde my-app!","version":"dev"}
```

**Al hacer push de un tag (`v1.0.0`):**

* GitHub Actions compila la imagen para `amd64` y `arm64`.
* La sube automáticamente a GitHub Container Registry.
* Puedes verla en `https://github.com/<user>/<repo>/packages`.

---

## 8. Explicación resumida

| Componente        | Función                                           |
| ----------------- | ------------------------------------------------- |
| **Dockerfile**    | Define cómo se construye la imagen.               |
| **.dockerignore** | Evita copiar archivos innecesarios al contenedor. |
| **CI Workflow**   | Ejecuta pruebas automáticas.                      |
| **CD Workflow**   | Publica imágenes multi-arch en GHCR/Docker Hub.   |
| **Buildx**        | Permite builds multi-arquitectura.                |
| **QEMU**          | Emula arquitecturas distintas (arm64, amd64).     |

---

## 9.  Resultado final

Con este setup tendrás:
Tests automáticos en PRs
Builds reproducibles con Docker
Publicación automática de imágenes versionadas
Multi-arquitectura (x86 + ARM)
Cache de capas para builds más rápidos

